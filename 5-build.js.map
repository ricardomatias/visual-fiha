{"version":3,"sources":["webpack:///./mapping/data.js?a593","webpack:///./resolve.js?dc1f"],"names":[],"mappings":";;;;;;AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,YAAY;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,+DAA+D;AAC/D,KAAK;;AAEL;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,IAAI;AACL;AACA,cAAc;AACd;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,WAAW,EAAE;AACtD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;;AAGH;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,0B;;;;;;;;ACpOA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yB","file":"5-build.js","sourcesContent":["'use strict';\n\nvar resolve = require('./../resolve');\nvar assign = require('lodash.assign');\nvar State = require('ampersand-state');\nvar Collection = require('ampersand-collection');\n\nfunction cleanFnFromExport(item) {\n  item.transformFunction = item.transformFunction || item.fn.toString();\n  delete item.fn;\n  return item;\n}\n\nfunction compileTransformFunction(fn) {\n  fn = fn || function(val) { return val; };\n  var compiled;\n\n  // proxy the ramda functions\n  var ramdaMethods = '';\n  var ramda = require('ramda');\n  Object.keys(ramda)\n    .filter(function(name) {\n      return name.length > 1 && typeof ramda[name] === 'function';\n    })\n    .forEach(function(name) {\n      ramdaMethods += '\\nvar ' + name + ' = ramda.' + name + ';';\n    });\n\n  var str = `compiled = (function() {\n  // override some stuff that should not be used\n  var navigator, window, global, document, module, exports;\n\n  ${ ramdaMethods }\n  return function(val, oldVal) {\n    var result;\n    try {\n      result = (${ fn.toString() })(val, oldVal);\n    }\n    catch(e) {\n      result = e;\n    }\n    return result;\n  };\n})();`;\n  try {\n    eval(str);// jshint ignore:line\n  }\n  catch (e) {\n    compiled = function(val) { return val; };\n  }\n  return compiled;\n}\n\nvar MappingEmitter = State.extend({\n  idAttribute: 'name',\n\n  props: {\n    targets: ['array', true, function() { return []; }],\n    transformFunction: 'any',\n    source: ['string', false, ''],\n    name: ['string', true, null]\n  },\n\n  derived: {\n    fn: {\n      deps: ['transformFunction'],\n      fn: function() {\n        return compileTransformFunction(this.transformFunction);\n      }\n    },\n    sourceState: {\n      deps: ['source'],\n      fn: function() {\n        if (this.source.indexOf('midi:') === 0) return;\n        var sourcePath = this.source.split('.');\n        sourcePath.pop();\n        sourcePath = sourcePath.join('.');\n        return this.collection.resolve(sourcePath);\n      }\n    },\n    sourceProperty: {\n      deps: ['source'],\n      fn: function() {\n        if (this.source.indexOf('midi:') === 0) return;\n        var sourcePath = this.source.split('.');\n        return sourcePath.pop();\n      }\n    }\n  },\n});\n\nvar Mappings = Collection.extend({\n  model: MappingEmitter,\n\n  initialize: function(models, options) {\n    if (!options.context) throw new Error('Missing context option for Mappings');\n    var readonly;\n    if (typeof options.readonly === 'undefined') {\n      readonly = this.readonly = typeof DedicatedWorkerGlobalScope === 'undefined';\n    }\n    else {\n      readonly = this.readonly = options.readonly;\n    }\n\n    this.on('reset', function(collection, info) {\n      this.unbindMappings(info.previousModels).bindMappings(collection.models);\n    });\n    this.on('remove', function(model) {\n      this.unbindMappings([model]);\n    });\n    this.on('add', function(model) {\n      this.bindMappings([model]);\n    });\n\n    this.context = options.context;\n  },\n\n\n  bindMappings: function(mappings) {\n    if (this.readonly) return this;\n\n    (mappings || []).forEach(function(mapping) {\n      if (!mapping.sourceState) return;\n      this.listenTo(mapping.sourceState, 'all', function(evtName, source, value) {\n        if (evtName !== 'change:' + mapping.sourceProperty) return;\n        this.process([mapping], value);\n      });\n    }, this);\n\n    return this;\n  },\n\n  unbindMappings: function(mappings) {\n    if (this.readonly) return this;\n\n    (mappings || []).forEach(function(mapping) {\n      if (!mapping.sourceState) return;\n      this.stopListening(mapping.sourceState, 'all');\n    }, this);\n\n    return this;\n  },\n\n\n  findMappingsBySource: function(path) {\n    return this.models.filter(function(mapping) {\n      return mapping.source === path;\n    });\n  },\n\n  findMappingByTarget: function(path) {\n    return this.models.find(function(mapping) {\n      return mapping.targets.indexOf(path) > -1;\n    });\n  },\n\n  import: function(data, reset) {\n    if (reset) {\n      this.reset(data);\n    }\n    else {\n      this.set(data);\n    }\n    return this;\n  },\n\n  serialize: function() {\n    return Collection.prototype\n            .serialize.apply(this, arguments)\n            .map(cleanFnFromExport);\n  },\n\n  toJSON: function () {\n    return this.map(function (model) {\n      if (model.toJSON) {\n        return model.toJSON();\n      }\n      else {\n        var out = {};\n        assign(out, model);\n        delete out.collection;\n        return out;\n      }\n    })\n    .map(cleanFnFromExport);\n  },\n\n  export: function() {\n    return this.serialize();\n  },\n\n  resolve: function(path) {\n    return resolve(path, this.context);\n  },\n\n  process: function(sources, value) {\n    sources.forEach(function(info) {\n      info.targets.forEach(function(target) {\n        var parts = target.split('.');\n        var targetProperty = parts.pop();\n        var targetStatePath = parts.join('.');\n        var state;\n        try {\n          state = this.resolve(targetStatePath);\n        } catch(e) {}\n        if (!state) return;\n\n        var finalValue = info.fn(value, state.get(targetProperty));\n        if (finalValue instanceof Error) return;\n        try {\n          state.set(targetProperty, finalValue);\n        }\n        catch (e) {\n          console.info(e.message);\n        }\n      }, this);\n    }, this);\n\n    return this;\n  },\n\n  processMIDI: function(deviceName, property, value) {\n    var sources = this.findMappingsBySource('midi:' + deviceName + '.' + property);\n    if (!sources || !sources.length) return this;\n    return this.process(sources, value);\n  }\n});\n\nmodule.exports = Mappings;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./mapping/data.js\n// module id = 142\n// module chunks = 3 5","'use strict';\n\nfunction resolve(path, context) {\n  if (!context) throw new Error('Missing context to solve mapping path');\n\n  function solver(str) {\n    var parts = str.split('.');\n\n    var f = function(instance) {\n      if (!parts.length) return instance;\n\n      var part = parts.shift();\n      if (instance[part] && instance[part].isCollection) {\n        return f(instance[part].get(parts.shift()));\n      }\n      else if (typeof instance[part] !== 'undefined') {\n        return f(instance[part]);\n      }\n    };\n    return f;\n  }\n\n  return solver(path)(context);\n}\n\nmodule.exports = resolve;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./resolve.js\n// module id = 654\n// module chunks = 3 5"],"sourceRoot":""}