<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - src/layer/canvas/scripts/solids/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>src/layer/canvas/scripts/solids/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">50.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">841</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">171.87</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">21.22</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;
// borrowed from
// https://www.mathsisfun.com/geometry/images/polyhedra.js
function polyhedraMain(shapeName) {
    this.version = &#039;0.92&#039;;
    this.shapeName = typeof shapeName !== &#039;undefined&#039; ? shapeName : &#039;pent-pyramid&#039;;
    this.curvyQ = [&#039;cone&#039;, &#039;cylinder&#039;, &#039;sphere&#039;, &#039;hemisphere&#039;].indexOf(this.shapeName) &gt;= 0;
    this.flatyQ = [&#039;plane&#039;, &quot;coplanar&quot;].indexOf(this.shapeName) &gt;= 0;
    pointsQ = false;
    w = 450;
    h = 450;
    var s = &quot;&quot;;
    s += &#039;&lt;div style=&quot;position:relative; width:&#039; + w + &#039;px; height:&#039; + h + &#039;px; border: 1px solid blue; border-radius: 10px;  margin:auto; display:block;&quot;&gt;&#039;;
    s += &#039;&lt;canvas id=&quot;canvasId&quot; width=&quot;&#039; + w + &#039;&quot; height=&quot;&#039; + h + &#039;&quot; style=&quot;z-index:1;&quot;&gt;&lt;/canvas&gt;&#039;;
    s += &#039;&lt;button id=&quot;dragBtn&quot; onclick=&quot;toggleDrag()&quot; style=&quot;z-index:2; position: absolute; top: 3px; left: 3px;&quot; class=&quot;togglebtn lo&quot; &gt;Spin&lt;/button&gt;&#039;;
    if (this.curvyQ || this.flatyQ) {} else {
        s += &#039;&lt;button id=&quot;explodeBtn&quot; onclick=&quot;toggleExplode()&quot; style=&quot;z-index:2; position: absolute; top: 3px; left: 70px;&quot; class=&quot;togglebtn lo&quot; &gt;Explode&lt;/button&gt;&#039;;
        s += &#039;&lt;div style=&quot;position: absolute; top: 3px; right: 5px; font: 18px Arial;&quot;&gt;&#039;;
        s += &quot;Coloring: &quot;;
        s += getDropdownHTML([&#039;Multi&#039;, &#039;Shaded&#039;, &#039;Two&#039;, &#039;Glass&#039;, &#039;PureGlass&#039;, &#039;Beams&#039;], &#039;clrChg&#039;, &#039;clrType&#039;);
        s += &#039;&lt;/div&gt;&#039;;
    }
    if (this.shapeName == &quot;coplanar&quot;) {
        pointsQ = true;
        this.shapeName = &quot;3 points&quot;;
        s += &#039;&lt;div style=&quot;position: absolute; top: 3px; right: 5px; font: 18px Arial;&quot;&gt;&#039;;
        s += &quot;Type: &quot;;
        s += getDropdownHTML([&quot;3 points&quot;, &quot;4 coplanar points&quot;, &quot;4 points&quot;], &#039;coplanarChg&#039;, &#039;coplanarType&#039;);
        s += &#039;&lt;/div&gt;&#039;;
    }
    s += &#039;&lt;div id=&quot;copyrt&quot; style=&quot;font: 10px Arial; color: #6600cc; position:absolute; left:5px; bottom:3px;&quot;&gt;&amp;copy; 2016 MathsIsFun.com  v&#039; + this.version + &#039;&lt;/div&gt;&#039;;
    s += &#039;&lt;/div&gt;&#039;;
    document.write(s);
    el = document.getElementById(&#039;canvasId&#039;);
    ratio = 2;
    el.width = w * ratio;
    el.height = h * ratio;
    el.style.width = w + &quot;px&quot;;
    el.style.height = h + &quot;px&quot;;
    g = el.getContext(&quot;2d&quot;);
    g.setTransform(ratio, 0, 0, ratio, 0, 0);
    this.transMat = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]];
    this.f = 500;
    this.shapes = [];
    this.clrs = [&quot;#ff0000&quot;, &quot;#0000ff&quot;, &quot;#ff9900&quot;, &quot;#00ff00&quot;, &quot;#ffff00&quot;, &quot;#660066&quot;, &quot;#99ff00&quot;, &quot;#0099ff&quot;, &quot;#00ff99&quot;, &quot;#9900ff&quot;, &quot;#ff0099&quot;, &quot;#006666&quot;, &quot;#666600&quot;, &quot;#990000&quot;, &quot;#009999&quot;, &quot;#999900&quot;, &quot;#003399&quot;, &quot;#ff00ff&quot;, &quot;#993333&quot;, &quot;#330099&quot;];
    this.explodeQ = false;
    dragQ = false;
    draggingQ = false;
    prevmouseX = 0;
    prevmouseY = 0;
    this.poly = new Poly();
    xAngle = 2;
    yAngle = 4;
    zAngle = 0;
    el.addEventListener(&#039;touchstart&#039;, ontouchstart, false);
    el.addEventListener(&#039;touchmove&#039;, ontouchmove, false);
    el.addEventListener(&#039;mousedown&#039;, onmouseDown, false);
    el.addEventListener(&#039;mousemove&#039;, onmouseMove, false);
    el.addEventListener(&quot;mouseup&quot;, onmouseUp, false);
    init();
}
function ontouchstart(evt) {
    draggingQ = true;
    var touch = evt.targetTouches[0];
    var bRect = el.getBoundingClientRect();
    prevmouseX = (touch.clientX - bRect.left) * (el.width / ratio / bRect.width);
    prevmouseY = (touch.clientY - bRect.top) * (el.height / ratio / bRect.height);
}
function ontouchmove(evt) {
    var touch = evt.targetTouches[0];
    evt.clientX = touch.clientX;
    evt.clientY = touch.clientY;
    evt.touchQ = true;
    onmouseMove(evt);
    evt.preventDefault();
}
function onmouseDown(evt) {
    draggingQ = true;
    prevmouseX = mouseX;
    prevmouseY = mouseY;
}
function onmouseUp(evt) {
    draggingQ = false;
}
function onmouseMove(evt) {
    var bRect = el.getBoundingClientRect();
    mouseX = (evt.clientX - bRect.left) * (el.width / ratio / bRect.width);
    mouseY = (evt.clientY - bRect.top) * (el.height / ratio / bRect.height);
    if (dragQ) {
        if (draggingQ) {
            settransMat(-(prevmouseY - mouseY) * 3, (prevmouseX - mouseX) * 3, 0, transMat);
            prevmouseX = mouseX;
            prevmouseY = mouseY;
            update();
        }
    } else {
        yAngle = -(mouseX - w / 2) / 25;
        xAngle = (mouseY - h / 2) / 25;
    }
}
function toggleDrag() {
    dragQ = !dragQ;
    toggleBtn(&quot;dragBtn&quot;, dragQ);
    if (dragQ) {
        document.getElementById(&quot;dragBtn&quot;).innerHTML = &#039;Drag&#039;;
    } else {
        document.getElementById(&quot;dragBtn&quot;).innerHTML = &#039;Spin&#039;;
    }
}
function toggleExplode() {
    this.explodeQ = !this.explodeQ;
    toggleBtn(&quot;explodeBtn&quot;, this.explodeQ);
    restart();
}
function toggleBtn(btn, onq) {
    if (onq) {
        document.getElementById(btn).classList.add(&quot;hi&quot;);
        document.getElementById(btn).classList.remove(&quot;lo&quot;);
    } else {
        document.getElementById(btn).classList.add(&quot;lo&quot;);
        document.getElementById(btn).classList.remove(&quot;hi&quot;);
    }
}
function getDropdownHTML(opts, funcName, id) {
    var s = &#039;&#039;;
    s += &#039;&lt;select id=&quot;&#039; + id + &#039;&quot; style=&quot;font: 18px Arial; color: #6600cc; background: rgba(200,220,256,0.7); padding: 1px;&quot; autocomplete=&quot;off&quot; onchange=&quot;&#039; + funcName + &#039;()&quot;&gt;&#039;;
    for (var i = 0; i &lt; opts.length; i++) {
        var idStr = id + i;
        var chkStr = i == 99 ? &#039;checked&#039; : &#039;&#039;;
        s += &#039;&lt;option id=&quot;&#039; + idStr + &#039;&quot; value=&quot;&#039; + opts[i] + &#039;&quot; style=&quot;height:18px;&quot; &#039; + chkStr + &#039; &gt;&#039; + opts[i] + &#039;&lt;/option&gt;&#039;;
    }
    s += &#039;&lt;/select&gt;&#039;;
    return s;
}
function clrChg() {
    var el = document.getElementById(&#039;clrType&#039;);
    if (el.selectedIndex == -1)
        return null;
    var t = el.options[el.selectedIndex].text;
    setClrs(t);
    update();
}
function coplanarChg() {
    var el = document.getElementById(&#039;coplanarType&#039;);
    if (el.selectedIndex == -1)
        return null;
    var t = el.options[el.selectedIndex].text;
    shapeName = t;
    restart();
}
function getClrType() {
    if (this.curvyQ || this.flatyQ) {
        if (this.shapeName == &#039;plane&#039;) {
            return &quot;Glass&quot;;
        } else {
            return &quot;Shaded&quot;;
        }
    } else {
        var div = document.getElementById(&#039;clrType&#039;);
        if (div.selectedIndex == -1)
            return &#039;Multi&#039;;
        return div.options[div.selectedIndex].text;
    }
}
function init() {
    shapes = [];
    poly.shapeType = shapeName;
    setShapesFromPoly();
    settransMat(200, 50, 0, transMat);
    g.clearRect(0, 0, el.width, el.height);
    drawShapes();
    this.frameNo = 0;
    animate();
}
function restart() {
    shapes = [];
    poly.shapeType = shapeName;
    setShapesFromPoly();
    update();
}
function animate() {
    this.frameNo++;
    if (dragQ) {} else {
        settransMat(xAngle, yAngle, zAngle, transMat);
        update();
    }
    if (this.frameNo &lt; 1e8) {
        requestAnimationFrame(animate);
    }
}
function update() {
    g.clearRect(0, 0, el.width, el.height);
    drawShapes();
}
function drawShapes() {
    var prevDepth = 0;
    var sortNeededQ = false;
    for (var i = 0, len = shapes.length; i &lt; len; i++) {
        var shape = shapes[i];
        shape.drawsurface(false, &quot;N&quot;);
        if (i &gt; 0) {
            if (shape.depth &lt; prevDepth) {
                sortNeededQ = true;
            }
        }
        prevDepth = shape.depth;
    }
    if (sortNeededQ) {
        shapes.sort(compareDepth);
    }
}
function compareDepth(a, b) {
    if (a.depth &lt; b.depth)
        return -1;
    return 1;
}
function setShapesFromPoly() {
    var C = poly.getSolid();
    var i = 0;
    while (i &lt; C.length) {
        var surf = C[i];
        addShape3D(&quot;surface&quot;, coords2Lines(surf, poly.scale), 1, &#039;#ffffff&#039;, &#039;rgba(0,0,255,0.3)&#039;);
        i++;
    }
    setClrs(getClrType());
}
function coords2Lines(surf, Scale) {
    var P = [];
    var midPt = [0, 0, 0];
    for (var i = 0; i &lt; surf.length; i++) {
        if (i &lt; surf.length - 1) {
            var tonum = i + 1;
        } else {
            tonum = 0;
        }
        P[i] = [];
        if (surf[i] == undefined) {
            console.log(&quot;Error surface =&quot; + i, surf[i]);
        } else {
            for (var j = 0; j &lt; 3; j++) {
                P[i][j] = surf[i][j] * Scale;
                if (explodeQ)
                    midPt[j] += P[i][j];
            }
        }
    }
    if (explodeQ) {
        for (j = 0; j &lt; 3; j++) {
            midPt[j] /= surf.length;
        }
        for (i = 0; i &lt; surf.length; i++) {
            for (j = 0; j &lt; 3; j++) {
                P[i][j] += midPt[j] / 2;
            }
        }
    }
    return P;
}
function addShape3D(shapeType, pointarray, lineweight, lineClr, fillClr) {
    var shape = new Shape3D;
    shape.transMat = transMat;
    shape.f = this.f;
    shape.setPts(pointarray);
    shape.shapeType = shapeType;
    shape.lineweight = lineweight;
    shape.lineClr = lineClr;
    shape.fillClr = fillClr;
    shapes.push(shape);
}
function settransMat(x, y, z, M) {
    var vectorLength = Math.sqrt(x * x + y * y + z * z);
    if (vectorLength &gt; .0001) {
        x /= vectorLength;
        y /= vectorLength;
        z /= vectorLength;
        var Theta = vectorLength / 500;
        var cosT = Math.cos(Theta);
        var sinT = Math.sin(Theta);
        var tanT = 1 - cosT;
        var T = [[], [], []];
        T[0][0] = tanT * x * x + cosT;
        T[0][1] = tanT * x * y - sinT * z;
        T[0][2] = tanT * x * z + sinT * y;
        T[1][0] = tanT * x * y + sinT * z;
        T[1][1] = tanT * y * y + cosT;
        T[1][2] = tanT * y * z - sinT * x;
        T[2][0] = tanT * x * z - sinT * y;
        T[2][1] = tanT * y * z + sinT * x;
        T[2][2] = tanT * z * z + cosT;
        transMat = matMatMult(T, M);
    }
}
function matMatMult(A, B) {
    var C = [[], [], []];
    C[0][0] = A[0][0] * B[0][0] + A[0][1] * B[1][0] + A[0][2] * B[2][0];
    C[0][1] = A[0][0] * B[0][1] + A[0][1] * B[1][1] + A[0][2] * B[2][1];
    C[0][2] = A[0][0] * B[0][2] + A[0][1] * B[1][2] + A[0][2] * B[2][2];
    C[1][0] = A[1][0] * B[0][0] + A[1][1] * B[1][0] + A[1][2] * B[2][0];
    C[1][1] = A[1][0] * B[0][1] + A[1][1] * B[1][1] + A[1][2] * B[2][1];
    C[1][2] = A[1][0] * B[0][2] + A[1][1] * B[1][2] + A[1][2] * B[2][2];
    C[2][0] = A[2][0] * B[0][0] + A[2][1] * B[1][0] + A[2][2] * B[2][0];
    C[2][1] = A[2][0] * B[0][1] + A[2][1] * B[1][1] + A[2][2] * B[2][1];
    C[2][2] = A[2][0] * B[0][2] + A[2][1] * B[1][2] + A[2][2] * B[2][2];
    return C;
}
function setClrs(clrMethod) {
    for (var i = 0; i &lt; shapes.length; i++) {
        var shape = shapes[i];
        shape.clrMethod = clrMethod;
        switch (clrMethod) {
        case &quot;Multi&quot;:
            shape.fillClr = convertHexClr(clrs[i % clrs.length], 0.7);
            break;
        case &quot;Two&quot;:
            shape.fillClr = convertHexClr(clrs[i % 2], 0.8);
            break;
        case &quot;Smooth&quot;:
            var FromMiddle = parseInt(Math.abs(shapes.length / 2 - i));
            var blu = FromMiddle * 8 + 1;
            var ccc = rgb2hex([blu, 128, blu]);
            shape.fillClr = ccc;
            break;
        case &quot;Glass&quot;:
        case &quot;PureGlass&quot;:
            shape.doShading();
            break;
        case &quot;Shaded&quot;:
            shape.doShading();
            break;
        default:
        }
    }
}
function Poly() {
    this.shapeType = &#039;cube&#039;;
    this.shapeSource = &#039;calc&#039;;
    this.scale = 90;
}
Poly.prototype.getSolid = function() {
    var C = [];
    switch (this.shapeSource) {
    case &quot;file&quot;:
    case &quot;data&quot;:
        C = [];
        for (var i = 0; i &lt; solidFaces.length; i++) {
            var faceVerts = [];
            for (var j = 0; j &lt; solidFaces[i].length; j++) {
                faceVerts.push(vertices[solidFaces[i][j]]);
            }
            C.push(faceVerts);
        }
        clrMethod = &quot;Glass&quot;;
        Scale = 100;
        break;
    case &quot;calc&quot;:
        C = this.getCalcSolid();
        break;
    default:
    }
    return C;
}
;
Poly.prototype.getCalcSolid = function() {
    var C = [];
    this.scale = 90;
    var i;
    var j;
    switch (this.shapeType.toLowerCase()) {
    case &quot;net&quot;:
        C = [[[0, 0, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0]], [[1, 0, 0], [2, 0, 0], [2, 1, 0], [1, 1, 0]], [[2, 0, 0], [3, 0, 0], [3, 1, 0], [2, 1, 0]]];
        clrMethod = &quot;Glass&quot;;
        this.scale = 100;
        break;
    case &quot;sphere&quot;:
        C = this.createNSphere(3);
        clrMethod = &quot;Alternating&quot;;
        this.scale = 110;
        break;
    case &quot;hemisphere&quot;:
        C = CreateNSphere(3, true);
        clrMethod = &quot;Shaded&quot;;
        this.scale = 110;
        break;
    case &quot;cone&quot;:
        C = this.createNCone(60, 1.3);
        this.scale = 140;
        clrMethod = &quot;Smooth&quot;;
        break;
    case &quot;cylinder&quot;:
        C = this.createNCylinder(60);
        clrMethod = &quot;Smooth&quot;;
        this.scale = 110;
        break;
    case &quot;square-pyramid&quot;:
        C = this.createNCone(4, 0.5);
        this.scale = 180;
        break;
    case &quot;pent-pyramid&quot;:
        C = this.createNCone(5, 0.7);
        this.scale = 180;
        break;
    case &quot;tetrahedron&quot;:
        C = [[[1, 1, 1], [-1, 1, -1], [1, -1, -1]], [[-1, 1, -1], [-1, -1, 1], [1, -1, -1]], [[1, 1, 1], [1, -1, -1], [-1, -1, 1]], [[1, 1, 1], [-1, -1, 1], [-1, 1, -1]]];
        break;
    case &quot;irr-tetrahedron&quot;:
        C = [[[2, 1, -0.2], [-1, 1, -1], [1, -1, -1]], [[-1, 1, -1], [-1, -1, 1], [1, -1, -1]], [[2, 1, -0.2], [1, -1, -1], [-1, -1, 1]], [[2, 1, -0.2], [-1, -1, 1], [-1, 1, -1]]];
        this.scale = 80;
        break;
    case &quot;cube&quot;:
        C = [[[-1, -1, -1], [1, -1, -1], [1, -1, 1], [-1, -1, 1]], [[-1, -1, -1], [-1, -1, 1], [-1, 1, 1], [-1, 1, -1]], [[-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]], [[-1, 1, -1], [-1, 1, 1], [1, 1, 1], [1, 1, -1]], [[1, -1, -1], [1, 1, -1], [1, 1, 1], [1, -1, 1]], [[-1, -1, -1], [-1, 1, -1], [1, 1, -1], [1, -1, -1]]];
        break;
    case &quot;3 points&quot;:
        C = [[[-1, -1, -1], [1, -1, -1], [1, -1, 1]]];
        this.scale = 80;
        break;
    case &quot;4 coplanar points&quot;:
        C = [[[-1.5, -1, -1], [1, -1, -1], [0.3, -1, 1], [-1.5, -1, 1]]];
        this.scale = 80;
        break;
    case &quot;4 points&quot;:
        C = [[[-1.1, -2, -2], [1, -1, -1], [0.8, 2, 1]], [[1, -1, -1], [0.8, 2, 1], [1.5, -1, 1]]];
        this.scale = 60;
        break;
    case &quot;plane&quot;:
        var a = 0.5;
        var b = 0.5;
        var c = 0.5;
        var d = -3;
        C = [];
        for (i = 0; i &lt; 6; i++) {
            for (j = 0; j &lt; 6; j++) {
                C.push([[a, -b + d + i, -c + d + j], [a, b + d + i, -c + d + j], [a, b + d + i, c + d + j], [a, -b + d + i, c + d + j]]);
            }
        }
        this.scale = 80;
        break;
    case &quot;cuboid&quot;:
    case &quot;rect-prism&quot;:
        a = 1.2;
        b = 0.7;
        c = 0.7;
        C = [[[-a, -b, -c], [a, -b, -c], [a, -b, c], [-a, -b, c]], [[-a, -b, -c], [-a, -b, c], [-a, b, c], [-a, b, -c]], [[-a, -b, c], [a, -b, c], [a, b, c], [-a, b, c]], [[-a, b, -c], [-a, b, c], [a, b, c], [a, b, -c]], [[a, -b, -c], [a, b, -c], [a, b, c], [a, -b, c]], [[-a, -b, -c], [-a, b, -c], [a, b, -c], [a, -b, -c]]];
        break;
    case &quot;pent-prism&quot;:
        a = 1.2;
        b = 0.70;
        c = 0.73;
        d = 0.16;
        var e = 0.44;
        C = [[[-a, 0, b], [-a, c, d], [-a, e, -b], [-a, -e, -b], [-a, -c, d]], [[a, 0, b], [a, c, d], [a, e, -b], [a, -e, -b], [a, -c, d]], [[-a, 0, b], [-a, c, d], [a, c, d], [a, 0, b]], [[-a, c, d], [-a, e, -b], [a, e, -b], [a, c, d]], [[-a, e, -b], [-a, -e, -b], [a, -e, -b], [a, e, -b]], [[-a, -e, -b], [-a, -c, d], [a, -c, d], [a, -e, -b]], [[-a, -c, d], [-a, 0, b], [a, 0, b], [a, -c, d]]];
        break;
    case &quot;oct-prism&quot;:
        a = 1.1;
        b = 0.33;
        c = 0.79;
        C = [[[-a, b, c], [-a, c, b], [-a, c, -b], [-a, b, -c], [-a, -b, -c], [-a, -c, -b], [-a, -c, b], [-a, -b, c]], [[a, b, c], [a, c, b], [a, c, -b], [a, b, -c], [a, -b, -c], [a, -c, -b], [a, -c, b], [a, -b, c]]];
        for (i = 0; i &lt; 8; i++) {
            j = Maths.loop(i, 0, 7, 1);
            C.push([[C[0][i][0], C[0][i][1], C[0][i][2]], [C[0][j][0], C[0][j][1], C[0][j][2]], [C[1][j][0], C[1][j][1], C[1][j][2]], [C[1][i][0], C[1][i][1], C[1][i][2]]]);
        }
        break;
    case &quot;irr-pent-prism&quot;:
        a = 1.2;
        b = 0.70;
        c = 0.73;
        d = 0.16;
        e = 0.9;
        C = [[[-a, 0, b], [-a, c, d], [-a, e, -b], [-a, -e, -b], [-a, -c, d]], [[a, 0, b], [a, c, d], [a, e, -b], [a, -e, -b], [a, -c, d]], [[-a, 0, b], [-a, c, d], [a, c, d], [a, 0, b]], [[-a, c, d], [-a, e, -b], [a, e, -b], [a, c, d]], [[-a, e, -b], [-a, -e, -b], [a, -e, -b], [a, e, -b]], [[-a, -e, -b], [-a, -c, d], [a, -c, d], [a, -e, -b]], [[-a, -c, d], [-a, 0, b], [a, 0, b], [a, -c, d]]];
        break;
    case &quot;tri-prism-n&quot;:
        C = CreateNCylinder(3);
        this.scale = 100;
        break;
    case &quot;tri-prism&quot;:
        a = 1.2;
        b = 0.7;
        c = 0.7;
        d = 0.6;
        C = [[[-a, -b, -c], [-a, -b, c], [-a, d, 0]], [[a, -b, -c], [a, -b, c], [a, d, 0]], [[-a, -b, -c], [a, -b, -c], [a, -b, c], [-a, -b, c]], [[-a, -b, c], [a, -b, c], [a, d, 0], [-a, d, 0]], [[-a, -b, -c], [-a, d, 0], [a, d, 0], [a, -b, -c]]];
        break;
    case &quot;strange-prism&quot;:
        a = 1.2;
        b = 0.7;
        c = 0.7;
        C = [[[-a, -b, -c], [a, -b, -c], [a, -b, c]], [[-a, -b, -c], [-a, -b, c], [-a, b, c]], [[-a, -b, c], [a, -b, c], [a, b, c]], [[-a, b, -c], [-a, b, c], [a, b, c]], [[a, -b, -c], [a, b, -c], [a, b, c]], [[-a, -b, -c], [-a, b, -c], [a, b, -c]]];
        break;
    case &quot;octahedron&quot;:
        a = 3 / (2 * Math.sqrt(2));
        b = 3 / 2;
        C = [[[-a, 0, a], [-a, 0, -a], [0, b, 0]], [[-a, 0, -a], [a, 0, -a], [0, b, 0]], [[a, 0, -a], [a, 0, a], [0, b, 0]], [[a, 0, a], [-a, 0, a], [0, b, 0]], [[a, 0, -a], [-a, 0, -a], [0, -b, 0]], [[-a, 0, -a], [-a, 0, a], [0, -b, 0]], [[a, 0, a], [a, 0, -a], [0, -b, 0]], [[-a, 0, a], [a, 0, a], [0, -b, 0]]];
        Scale = 100;
        break;
    case &quot;dodecahedron&quot;:
        var phi = (1 + Math.sqrt(5)) / 2;
        // golden ratio
        a = 1;
        b = 1 / phi;
        c = 2 - phi;
        a *= 1.5;
        b *= 1.5;
        c *= 1.5;
        C = [[[c, 0, a], [-c, 0, a], [-b, b, b], [0, a, c], [b, b, b]], [[-c, 0, a], [c, 0, a], [b, -b, b], [0, -a, c], [-b, -b, b]], [[c, 0, -a], [-c, 0, -a], [-b, -b, -b], [0, -a, -c], [b, -b, -b]], [[-c, 0, -a], [c, 0, -a], [b, b, -b], [0, a, -c], [-b, b, -b]], [[0, a, -c], [0, a, c], [b, b, b], [a, c, 0], [b, b, -b]], [[0, a, c], [0, a, -c], [-b, b, -b], [-a, c, 0], [-b, b, b]], [[0, -a, -c], [0, -a, c], [-b, -b, b], [-a, -c, 0], [-b, -b, -b]], [[0, -a, c], [0, -a, -c], [b, -b, -b], [a, -c, 0], [b, -b, b]], [[a, c, 0], [a, -c, 0], [b, -b, b], [c, 0, a], [b, b, b]], [[a, -c, 0], [a, c, 0], [b, b, -b], [c, 0, -a], [b, -b, -b]], [[-a, c, 0], [-a, -c, 0], [-b, -b, -b], [-c, 0, -a], [-b, b, -b]], [[-a, -c, 0], [-a, c, 0], [-b, b, b], [-c, 0, a], [-b, -b, b]]];
        break;
    case &quot;icosahedron-intersected&quot;:
        phi = (1 + Math.sqrt(5)) / 2;
        // golden ratio
        a = 1;
        b = 1 / phi;
        c = 2 - phi;
        a *= 1.5;
        b *= 1.5;
        c *= 1.5;
        C = [[[0, b, -a], [b, a, 0], [-b, a, 0]], [[0, 0, 0], [-b, a, 0], [b, a, 0]], [[0, 0, 0], [0, -b, a], [-a, 0, b]], [[0, 0, 0], [a, 0, b], [0, -b, a]], [[0, b, -a], [0, 0, 0], [a, 0, -b]], [[0, b, -a], [-a, 0, -b], [0, 0, 0]], [[0, -b, a], [b, -a, 0], [-b, -a, 0]], [[0, 0, 0], [-b, -a, 0], [b, -a, 0]], [[-b, a, 0], [-a, 0, b], [-a, 0, -b]], [[-b, -a, 0], [-a, 0, -b], [-a, 0, b]], [[b, a, 0], [a, 0, -b], [a, 0, b]], [[b, -a, 0], [a, 0, b], [a, 0, -b]], [[0, 0, 0], [-a, 0, b], [-b, a, 0]], [[0, 0, 0], [b, a, 0], [a, 0, b]], [[0, b, -a], [-b, a, 0], [-a, 0, -b]], [[0, b, -a], [a, 0, -b], [b, a, 0]], [[0, 0, 0], [-a, 0, -b], [-b, -a, 0]], [[0, 0, 0], [b, -a, 0], [a, 0, -b]], [[0, -b, a], [-b, -a, 0], [-a, 0, b]], [[0, -b, a], [a, 0, b], [b, -a, 0]]];
        break;
    case &quot;icosahedron&quot;:
        phi = (1 + Math.sqrt(5)) / 2;
        // golden ratio
        a = 1 / 2;
        b = 1 / (2 * phi);
        a *= 3;
        b *= 3;
        C = [[[0, b, -a], [b, a, 0], [-b, a, 0]], [[0, b, a], [-b, a, 0], [b, a, 0]], [[0, b, a], [0, -b, a], [-a, 0, b]], [[0, b, a], [a, 0, b], [0, -b, a]], [[0, b, -a], [0, -b, -a], [a, 0, -b]], [[0, b, -a], [-a, 0, -b], [0, -b, -a]], [[0, -b, a], [b, -a, 0], [-b, -a, 0]], [[0, -b, -a], [-b, -a, 0], [b, -a, 0]], [[-b, a, 0], [-a, 0, b], [-a, 0, -b]], [[-b, -a, 0], [-a, 0, -b], [-a, 0, b]], [[b, a, 0], [a, 0, -b], [a, 0, b]], [[b, -a, 0], [a, 0, b], [a, 0, -b]], [[0, b, a], [-a, 0, b], [-b, a, 0]], [[0, b, a], [b, a, 0], [a, 0, b]], [[0, b, -a], [-b, a, 0], [-a, 0, -b]], [[0, b, -a], [a, 0, -b], [b, a, 0]], [[0, -b, -a], [-a, 0, -b], [-b, -a, 0]], [[0, -b, -a], [b, -a, 0], [a, 0, -b]], [[0, -b, a], [-b, -a, 0], [-a, 0, b]], [[0, -b, a], [a, 0, b], [b, -a, 0]]];
        this.scale = 80;
        break;
    default:
    }
    return C;
}
;
Poly.prototype.createNCone = function(ngon, ht) {
    var D = [];
    D[0] = [];
    var sumx = 0;
    var sumy = 0;
    for (var i = 0; i &lt; ngon; i++) {
        var Angle = (Math.PI * 2 * i) / ngon;
        D[0][i] = [];
        D[0][i][0] = Math.sin(Angle) * 0.8;
        D[0][i][1] = Math.cos(Angle) * 0.8;
        D[0][i][2] = -ht / 2;
        sumx = sumx + D[0][i][0];
        sumy = sumy + D[0][i][1];
    }
    var apexx = sumx / ngon;
    var apexy = sumy / ngon;
    for (i = 0; i &lt; ngon; i++) {
        var n = i + 1;
        D[n] = [];
        D[n][0] = [];
        D[n][0][0] = apexx;
        D[n][0][1] = apexy;
        D[n][0][2] = ht;
        D[n][1] = [];
        D[n][1][0] = D[0][i][0];
        D[n][1][1] = D[0][i][1];
        D[n][1][2] = D[0][i][2];
        var i1 = i + 1;
        if (i1 == ngon)
            i1 = 0;
        D[n][2] = [];
        D[n][2][0] = D[0][i1][0];
        D[n][2][1] = D[0][i1][1];
        D[n][2][2] = D[0][i1][2];
    }
    return D;
}
;
Poly.prototype.createNCylinder = function(ngon) {
    var D = [];
    D[0] = [];
    for (var i = 0; i &lt; ngon; i++) {
        var Angle = (Math.PI * 2 * i) / ngon;
        D[0][i] = [];
        D[0][i][0] = Math.sin(Angle) * 0.8;
        D[0][i][1] = Math.cos(Angle) * 0.8;
        D[0][i][2] = 1.4;
    }
    D[1] = [];
    for (i = 0; i &lt; ngon; i++) {
        Angle = (Math.PI * 2 * i) / ngon;
        D[1][i] = [];
        D[1][i][0] = Math.sin(Angle) * 0.8;
        D[1][i][1] = Math.cos(Angle) * 0.8;
        D[1][i][2] = -1.1;
    }
    for (i = 0; i &lt; ngon; i++) {
        var n = i + 2;
        D[n] = [];
        var i1 = i + 1;
        if (i1 == ngon)
            i1 = 0;
        D[n][0] = [];
        D[n][0][0] = D[0][i][0];
        D[n][0][1] = D[0][i][1];
        D[n][0][2] = D[0][i][2];
        D[n][1] = [];
        D[n][1][0] = D[0][i1][0];
        D[n][1][1] = D[0][i1][1];
        D[n][1][2] = D[0][i1][2];
        D[n][2] = [];
        D[n][2][0] = D[1][i1][0];
        D[n][2][1] = D[1][i1][1];
        D[n][2][2] = D[1][i1][2];
        D[n][3] = [];
        D[n][3][0] = D[1][i][0];
        D[n][3][1] = D[1][i][1];
        D[n][3][2] = D[1][i][2];
    }
    return D;
}
;
Poly.prototype.sphereNormalise = function(p) {
    var vectorLength = Math.sqrt(p[0] * p[0] + p[1] * p[1] + p[2] * p[2]);
    if (vectorLength != 0) {
        p[0] /= vectorLength;
        p[1] /= vectorLength;
        p[2] /= vectorLength;
    } else {
        p[0] = 0;
        p[1] = 0;
        p[2] = 0;
    }
}
;
function Shape3D() {
    var rotSelfMatrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]];
    var rotSelfQ = false;
    this.velQ = false;
    this.lt = w / 2;
    this.tp = h / 2;
    this.eye = new Pt3d;
    this.eye.setMe(0, 0, 400);
    this.pts = [];
    this.lineweight;
    this.lineClr = &#039;white&#039;;
    this.fillClr = &#039;rgba(255,0,0,0.9)&#039;;
    this.shapeType = &quot;surf&quot;;
    this.clrMethod = &quot;None&quot;;
    this.depth = 0;
    this.showPtsQ = false;
    this.centroid = new Pt3d();
    this.vel3d = new Pt3d;
    this.hideCount = 0;
}
Shape3D.prototype.setPts = function(apts) {
    this.pts = [];
    for (var i = 0; i &lt; apts.length; i++) {
        var p3d = new Pt3d;
        p3d.setMe(apts[i][0], apts[i][1], apts[i][2]);
        this.pts.push(p3d);
    }
    this.calcCentroid();
}
;
Shape3D.prototype.doShading = function() {
    var alpha = 0.8;
    switch (this.clrMethod) {
    case &#039;Glass&#039;:
    case &#039;PureGlass&#039;:
        alpha = 0.5;
        break;
    default:
    }
    var angle = this.getNormalAngle(this.pts, 0);
    var dark = (1 - angle / Math.PI);
    var red = (dark * 255 &gt;&gt; 0) + 1;
    var grn = (dark * 255 &gt;&gt; 0) + 1;
    angle = this.getNormalAngle(this.pts, 1);
    dark = (1 - angle / Math.PI);
    var blu = (dark * 255 &gt;&gt; 0) + 1;
    this.fillClr = &#039;rgba(&#039; + red + &#039;,&#039; + grn + &#039;,&#039; + blu + &#039;,&#039; + alpha + &#039;)&#039;;
}
Shape3D.prototype.getNormalAngle = function(pts, dimN) {
    var a = [pts[1].x - pts[0].x, pts[1].y - pts[0].y, pts[1].z - pts[0].z];
    var b = [pts[2].x - pts[1].x, pts[2].y - pts[1].y, pts[2].z - pts[1].z];
    var cross = [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    var mag = Math.sqrt(cross[0] * cross[0] + cross[1] * cross[1] + cross[2] * cross[2]);
    var theta = Math.acos(cross[dimN] / mag);
    return theta;
}
Shape3D.prototype.calcCentroid = function() {
    centroid = new Pt3d;
    for (var i = 0; i &lt; this.pts.length; i++) {
        centroid.addPtMe(this.pts[i]);
    }
    if (this.pts.length &gt; 0) {
        centroid.x /= this.pts.length;
        centroid.y /= this.pts.length;
        centroid.z /= this.pts.length;
    }
}
;
Shape3D.prototype.drawsurface = function(aboutEyeQ, viewType) {
    var xsum = 0;
    var ysum = 0;
    var zsum = 0;
    var clips = [];
    var zMin = Number.MAX_VALUE;
    var zMax = -Number.MAX_VALUE;
    var i = 0;
    var ptRot;
    while (i &lt; this.pts.length) {
        var pt3d = this.pts[i];
        if (this.aboutEyeQ) {} else {
            ptRot = this.matPtMult(transMat, pt3d);
            clips.push(ptRot);
        }
        zMin = Math.min(zMin, ptRot.z);
        zMax = Math.max(zMax, ptRot.z);
        xsum += ptRot.x;
        ysum += ptRot.y;
        zsum += ptRot.z;
        i++;
    }
    var pt2s = [];
    i = 0;
    while (i &lt; clips.length) {
        var p3d = clips[i];
        var pt = new Pt();
        pt.x = this.lt + (this.eye.z * (p3d.x)) / (this.eye.z + p3d.z);
        pt.y = this.tp + (this.eye.z * (p3d.y)) / (this.eye.z + p3d.z);
        pt2s.push(pt);
        i++;
    }
    var fillQ = true;
    var strokeQ = true;
    switch (this.clrMethod) {
    case &quot;Glass&quot;:
        g.lineWidth = 1;
        g.strokeStyle = &#039;#000000&#039;;
        g.fillStyle = this.fillClr;
        break;
    case &quot;PureGlass&quot;:
        g.lineWidth = 3;
        g.strokeStyle = &#039;#ffffff&#039;;
        g.fillStyle = this.fillClr;
        break;
    case &quot;Beams&quot;:
        g.lineWidth = 18;
        g.strokeStyle = &#039;#444444&#039;;
        g.fillStyle = &#039;rgba(250,250,250,0.2)&#039;;
        g.lineJoin = &quot;round&quot;;
        break;
    case &quot;Shaded&quot;:
        g.fillStyle = this.fillClr;
        strokeQ = false;
        break;
    default:
        g.lineWidth = 1;
        g.strokeStyle = this.lineClr;
        g.fillStyle = this.fillClr;
    }
    if (pt2s.length &gt; 2) {
        g.beginPath();
        for (i = 0,
        len = pt2s.length; i &lt; len; i++) {
            pt = pt2s[i];
            if (i == 0) {
                g.moveTo(pt.x, pt.y);
            } else {
                g.lineTo(pt.x, pt.y);
            }
        }
        g.closePath();
        if (strokeQ)
            g.stroke();
        if (fillQ)
            g.fill();
    }
    if (pointsQ) {
        for (i = 0,
        len = pt2s.length; i &lt; len; i++) {
            pt = pt2s[i];
            g.beginPath();
            g.fillStyle = &quot;rgba(0,0,255,0.3)&quot;;
            g.arc(pt.x, pt.y, 4, 0, 2 * Math.PI);
            g.closePath();
            g.stroke();
            g.fill();
        }
    }
    var iRecip = 1 / (pt2s.length + 1);
    xsum *= iRecip;
    ysum *= iRecip;
    zsum = f - zsum * iRecip;
    this.depth = (xsum * xsum + ysum * ysum + zsum * zsum) / 10000;
}
;
Shape3D.prototype.matPtMult = function(A, B) {
    var C = new Pt3d;
    C.x = A[0][0] * B.x + A[0][1] * B.y + A[0][2] * B.z;
    C.y = A[1][0] * B.x + A[1][1] * B.y + A[1][2] * B.z;
    C.z = A[2][0] * B.x + A[2][1] * B.y + A[2][2] * B.z;
    return C;
}
;
function Pt() {
    this.x = 0;
    this.y = 0;
}
function Pt3d() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
}
Pt3d.prototype.setMe = function(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
}
;
Pt3d.prototype.addPtMe = function(pt3d, factor) {
    factor = typeof factor !== &#039;undefined&#039; ? factor : 1;
    if (factor == 1) {
        this.x += pt3d.x;
        this.y += pt3d.y;
        this.z += pt3d.z;
    } else {
        this.x += pt3d.x * factor;
        this.y += pt3d.y * factor;
        this.z += pt3d.z * factor;
    }
}
;
function convertHexClr(hex, opacity) {
    hex = hex.replace(&#039;#&#039;, &#039;&#039;);
    var r = parseInt(hex.substring(0, 2), 16);
    var g = parseInt(hex.substring(2, 4), 16);
    var b = parseInt(hex.substring(4, 6), 16);
    return &#039;rgba(&#039; + r + &#039;,&#039; + g + &#039;,&#039; + b + &#039;,&#039; + opacity + &#039;)&#039;;
}
function rgb2hex(color) {
    var hex = [];
    for (var i = 0; i &lt; 3; i++) {
        hex.push(color[i].toString(16));
        if (hex[i].length &lt; 2) {
            hex[i] = &quot;0&quot; + hex[i];
        }
    }
    return &quot;#&quot; + hex[0] + hex[1] + hex[2];
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
